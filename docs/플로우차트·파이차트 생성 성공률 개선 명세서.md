# 플로우차트·파이차트 생성 성공률 개선 명세서

> **프로젝트**: SnapChart  
> **버전**: v1.0  
> **작성일**: 2025-10-17  
> **담당**: 아테나 (AI 프롬프트 엔지니어) + 덱스 (백엔드 구현)  
> **목표**: 플로우차트 & 파이차트 생성 성공률 **75% → 95%+** 달성

---

## 📊 Executive Summary

### 현재 상황
```
테스트 결과 (Node.js 환경):
- 전체 성공률: 75% (6/8)
- ❌ 플로우차트 실패 (40% 사용 예상, Critical)
- ❌ 파이 차트 실패 (10% 사용 예상, High)
- ✅ 나머지 6개 타입 성공
```

### 개선 전략
```
1. 🎯 프롬프트 엔지니어링 (핵심)
   - Few-shot 학습
   - Gemini 최적화 템플릿
   - 명시적 출력 포맷 지정

2. ⚡ 런타임 최적화
   - Node.js → Bun (4배 빠른 실행)
   - 응답 시간 단축

3. 🔄 재시도 메커니즘
   - 실패 시 자동 재시도 (최대 3회)
   - Fallback to Claude

4. ✅ 검증 시스템
   - Mermaid 문법 사전 검증
   - 실시간 렌더링 테스트
```

### 예상 결과
```
📈 목표 성공률: 95%+ (8개 중 7.6개)
⚡ 응답 속도: 평균 6.2초 → 4.5초 (Bun 적용)
💰 비용: 동일 ($0.0020/요청)
🎯 신뢰도: 상용 서비스 수준 달성
```

---

## 🎯 Part 1: 실패 원인 분석

### 1.1 플로우차트 실패 원인

#### 현재 프롬프트 (실패)
```
"로그인 프로세스를 Mermaid 플로우차트로 만들어줘. 
시작→이메일입력→비밀번호입력→인증→성공/실패"
```

#### 실패 패턴 분석
```typescript
// Gemini가 생성한 잘못된 코드 (추정)
graph TD
  Start[시작] --> Email
  Email[이메일입력] --> Password
  ...
  // 문제 1: 'graph TD' 대신 'flowchart TD' 필요 (Mermaid v9.0+)
  // 문제 2: 조건 분기 문법 오류
  // 문제 3: 화살표 라벨 처리 미흡
```

#### 근본 원인
1. **모호한 지시사항**
   - "플로우차트로 만들어줘" → Gemini가 graph TD 사용
   - Mermaid v9.0+ 이후 flowchart TD 권장

2. **예제 부족**
   - Few-shot 예제 없이 Zero-shot 요청
   - Gemini는 예제 기반 학습에 강함

3. **출력 포맷 불명확**
   - "코드만 출력"이라고 했지만 설명 포함 가능성
   - 마크다운 코드 블록 생성 가능성

### 1.2 파이 차트 실패 원인

#### 현재 프롬프트 (실패)
```
"월별 매출 비중을 Mermaid pie 차트로. 
1월(25%), 2월(30%), 3월(45%)"
```

#### 실패 패턴 분석
```typescript
// Gemini가 생성한 잘못된 코드 (추정)
pie
  title 월별 매출 비중
  "1월" : 25
  "2월" : 30
  "3월" : 45
  // 문제: 퍼센트 합계가 100이지만 Mermaid는 비율 자동 계산
  // 또는: 문법 오류 (showData, 따옴표 처리 등)
```

#### 근본 원인
1. **데이터 포맷 혼란**
   - "25%" vs 25 (숫자만 vs 퍼센트 표기)
   - Mermaid pie는 숫자만 받음

2. **문법 민감성**
   - 띄어쓰기, 따옴표, 콜론 위치에 민감
   - Gemini가 미세한 문법 오류 발생 가능

3. **검증 로직 부재**
   - 생성된 코드의 문법 검증 없음
   - 퍼센트 합계 검증 없음

---

## 🔧 Part 2: 개선 솔루션 설계

### 2.1 플로우차트 프롬프트 개선

#### ✅ 개선된 프롬프트 v2.0

```typescript
const FLOWCHART_SYSTEM_PROMPT = `당신은 Mermaid 플로우차트 전문가입니다.

**중요 규칙**:
1. 반드시 \`flowchart TD\` 또는 \`flowchart LR\`로 시작
2. 노드 ID는 영문 (A, B, C 등)
3. 한국어 라벨은 대괄호 안에: A[시작]
4. 조건 분기는 중괄호: B{로그인?}
5. 화살표 라벨은 파이프: A -->|예| B
6. 코드만 출력 (설명, 마크다운 블록 금지)

**출력 예제**:
flowchart TD
    A[시작] --> B{로그인 여부}
    B -->|예| C[대시보드]
    B -->|아니오| D[로그인 페이지]
    D --> E[완료]`;

const FLOWCHART_USER_PROMPT = (description: string) => `
다음 프로세스를 Mermaid flowchart로 생성하세요:

"${description}"

**필수 요구사항**:
- flowchart TD로 시작
- 노드 ID: A, B, C, ...
- 한국어 라벨만 사용
- 조건 분기 시 중괄호 사용
- 코드만 출력

**예제 출력**:
flowchart TD
    A[시작] --> B{확인}
    B -->|예| C[진행]
    B -->|아니오| D[종료]
`;
```

#### Few-Shot 학습 적용

```typescript
const FEW_SHOT_EXAMPLES = [
  {
    input: "회원가입 프로세스",
    output: `flowchart TD
    A[시작] --> B[이메일 입력]
    B --> C[비밀번호 입력]
    C --> D{유효성 검사}
    D -->|통과| E[가입 완료]
    D -->|실패| B`
  },
  {
    input: "결제 프로세스",
    output: `flowchart TD
    A[장바구니] --> B{재고 확인}
    B -->|있음| C[결제]
    B -->|없음| D[품절 알림]
    C --> E{결제 성공?}
    E -->|예| F[주문 완료]
    E -->|아니오| C`
  },
  {
    input: "로그인 프로세스",
    output: `flowchart TD
    A[시작] --> B[ID 입력]
    B --> C[PW 입력]
    C --> D{인증}
    D -->|성공| E[메인]
    D -->|실패| F[재시도]
    F --> B`
  }
];

// Gemini API 호출 시 Few-Shot 적용
const promptWithExamples = `
${FLOWCHART_SYSTEM_PROMPT}

**학습 예제 3개**:

예제 1:
입력: "${FEW_SHOT_EXAMPLES[0].input}"
출력:
${FEW_SHOT_EXAMPLES[0].output}

예제 2:
입력: "${FEW_SHOT_EXAMPLES[1].input}"
출력:
${FEW_SHOT_EXAMPLES[1].output}

예제 3:
입력: "${FEW_SHOT_EXAMPLES[2].input}"
출력:
${FEW_SHOT_EXAMPLES[2].output}

**이제 당신의 차례**:
입력: "${userInput}"
출력:
`;
```

### 2.2 파이 차트 프롬프트 개선

#### ✅ 개선된 프롬프트 v2.0

```typescript
const PIE_CHART_SYSTEM_PROMPT = `당신은 Mermaid 파이 차트 전문가입니다.

**중요 규칙**:
1. 반드시 \`pie\`로 시작
2. title 라인 추가 (선택)
3. 데이터 포맷: "라벨" : 숫자 (퍼센트 아님!)
4. 숫자 합계 무관 (Mermaid가 자동 비율 계산)
5. 한국어 라벨 사용
6. 코드만 출력 (설명, 마크다운 블록 금지)

**출력 예제**:
pie title 매출 비중
    "1월" : 25
    "2월" : 30
    "3월" : 45`;

const PIE_CHART_USER_PROMPT = (description: string, data: Record<string, number>) => `
다음 데이터를 Mermaid pie 차트로 생성하세요:

제목: "${description}"
데이터: ${JSON.stringify(data, null, 2)}

**필수 요구사항**:
- pie로 시작
- title 라인 추가
- "라벨" : 숫자 형식
- 퍼센트 기호(%) 사용 금지
- 코드만 출력

**예제 출력**:
pie title ${description}
    ${Object.entries(data).map(([key, val]) => `"${key}" : ${val}`).join('\n    ')}
`;
```

#### 데이터 전처리 & 검증

```typescript
interface PieChartData {
  title: string;
  data: Record<string, number>;
}

function validateAndPreprocessPieData(
  input: string
): PieChartData {
  // 1. 퍼센트 제거 및 숫자 추출
  const percentPattern = /(\d+)%/g;
  const numbers: number[] = [];
  let match;
  
  while ((match = percentPattern.exec(input)) !== null) {
    numbers.push(parseInt(match[1]));
  }
  
  // 2. 라벨 추출
  const labels = input.match(/[가-힣a-zA-Z0-9]+(?=\()/g) || [];
  
  // 3. 데이터 정규화
  const data: Record<string, number> = {};
  labels.forEach((label, i) => {
    data[label] = numbers[i] || 0;
  });
  
  // 4. 합계 검증 (경고만)
  const sum = Object.values(data).reduce((a, b) => a + b, 0);
  if (Math.abs(sum - 100) > 1) {
    console.warn(`⚠️ 퍼센트 합계 ${sum}% (100%가 아님)`);
  }
  
  return {
    title: extractTitle(input),
    data
  };
}

// 사용 예
const rawInput = "월별 매출 비중을 Mermaid pie 차트로. 1월(25%), 2월(30%), 3월(45%)";
const processed = validateAndPreprocessPieData(rawInput);
// { title: "월별 매출 비중", data: { "1월": 25, "2월": 30, "3월": 45 } }
```

---

## 🏗️ Part 3: 구현 아키텍처

### 3.1 시스템 구조

```
┌─────────────────────────────────────────────┐
│         사용자 입력 (자연어)                  │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 1: 입력 분석 & 전처리                  │
│  ├─ 다이어그램 타입 감지                     │
│  ├─ 데이터 추출 (파이차트의 경우)             │
│  └─ 프롬프트 템플릿 선택                     │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 2: 프롬프트 생성                       │
│  ├─ System Prompt (Few-Shot 포함)           │
│  ├─ User Prompt (명시적 지시사항)            │
│  └─ 예제 추가 (필요 시)                      │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 3: API 호출 (with Retry)               │
│  ├─ Gemini API (Primary)                    │
│  ├─ 재시도 (최대 3회)                        │
│  └─ Claude API (Fallback)                   │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 4: 응답 후처리                         │
│  ├─ 마크다운 코드 블록 제거                  │
│  ├─ 앞뒤 공백 제거                           │
│  └─ 설명 텍스트 제거                         │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 5: 문법 검증                           │
│  ├─ Mermaid 파서로 검증                      │
│  ├─ 실패 시 재생성 요청                      │
│  └─ 최대 3회 재시도                          │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│  Step 6: 렌더링 테스트                       │
│  ├─ Mermaid.js로 SVG 생성                    │
│  ├─ 성공 시 캐시 저장                        │
│  └─ 실패 시 에러 리포트                      │
└─────────────────┬───────────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────────┐
│         최종 Mermaid 코드 + SVG              │
└─────────────────────────────────────────────┘
```

### 3.2 핵심 모듈 설계

#### 📦 Module 1: PromptEngine

```typescript
// src/lib/prompt-engine.ts

export interface DiagramConfig {
  type: 'flowchart' | 'pie' | 'sequence' | 'gantt' | 'er' | 'state' | 'journey' | 'graph';
  systemPrompt: string;
  fewShotExamples?: Array<{ input: string; output: string }>;
  preprocessor?: (input: string) => any;
  validator?: (code: string) => boolean;
}

export class PromptEngine {
  private configs: Map<string, DiagramConfig>;
  
  constructor() {
    this.configs = new Map([
      ['flowchart', FLOWCHART_CONFIG],
      ['pie', PIE_CONFIG],
      // ... 나머지 타입
    ]);
  }
  
  async generatePrompt(
    type: string,
    userInput: string
  ): Promise<{ system: string; user: string }> {
    const config = this.configs.get(type);
    if (!config) throw new Error(`Unknown diagram type: ${type}`);
    
    // 전처리
    const processed = config.preprocessor 
      ? config.preprocessor(userInput)
      : userInput;
    
    // Few-Shot 예제 포함
    const system = config.fewShotExamples
      ? this.buildFewShotPrompt(config.systemPrompt, config.fewShotExamples)
      : config.systemPrompt;
    
    // User 프롬프트 생성
    const user = this.buildUserPrompt(type, processed);
    
    return { system, user };
  }
  
  private buildFewShotPrompt(
    systemPrompt: string,
    examples: Array<{ input: string; output: string }>
  ): string {
    const exampleText = examples.map((ex, i) => `
예제 ${i + 1}:
입력: "${ex.input}"
출력:
${ex.output}
`).join('\n');
    
    return `${systemPrompt}\n\n**학습 예제**:\n${exampleText}`;
  }
  
  private buildUserPrompt(type: string, data: any): string {
    // 타입별 User 프롬프트 템플릿
    switch (type) {
      case 'flowchart':
        return `다음 프로세스를 flowchart로 생성하세요:\n"${data}"\n\n코드만 출력하세요.`;
      case 'pie':
        return `다음 데이터를 pie 차트로:\n제목: "${data.title}"\n데이터: ${JSON.stringify(data.data)}\n\n코드만 출력하세요.`;
      default:
        return data;
    }
  }
}
```

#### 📦 Module 2: APIClient (with Retry)

```typescript
// src/lib/api-client.ts

import { GoogleGenerativeAI } from '@google/generative-ai';
import Anthropic from '@anthropic-ai/sdk';

export interface GenerateOptions {
  maxRetries?: number;
  timeout?: number;
  fallbackToClaude?: boolean;
}

export class DiagramAPIClient {
  private gemini: GoogleGenerativeAI;
  private claude: Anthropic;
  
  constructor(geminiKey: string, claudeKey?: string) {
    this.gemini = new GoogleGenerativeAI(geminiKey);
    if (claudeKey) {
      this.claude = new Anthropic({ apiKey: claudeKey });
    }
  }
  
  async generate(
    systemPrompt: string,
    userPrompt: string,
    options: GenerateOptions = {}
  ): Promise<string> {
    const {
      maxRetries = 3,
      timeout = 30000,
      fallbackToClaude = true
    } = options;
    
    // Primary: Gemini
    for (let i = 0; i < maxRetries; i++) {
      try {
        const result = await this.callGemini(systemPrompt, userPrompt, timeout);
        
        // 후처리
        const cleaned = this.cleanResponse(result);
        
        // 기본 검증
        if (this.isValidMermaid(cleaned)) {
          return cleaned;
        }
        
        console.warn(`⚠️ Gemini 시도 ${i + 1}/${maxRetries} 실패: 유효하지 않은 코드`);
      } catch (error) {
        console.error(`❌ Gemini 시도 ${i + 1}/${maxRetries} 실패:`, error.message);
      }
      
      // 재시도 전 대기 (Exponential Backoff)
      if (i < maxRetries - 1) {
        await this.sleep(Math.pow(2, i) * 1000);
      }
    }
    
    // Fallback: Claude
    if (fallbackToClaude && this.claude) {
      console.log('🔄 Fallback to Claude...');
      try {
        return await this.callClaude(systemPrompt, userPrompt);
      } catch (error) {
        console.error('❌ Claude fallback 실패:', error.message);
      }
    }
    
    throw new Error('모든 시도 실패: Gemini (3회) + Claude fallback');
  }
  
  private async callGemini(
    system: string,
    user: string,
    timeout: number
  ): Promise<string> {
    const model = this.gemini.getGenerativeModel({ 
      model: 'gemini-2.0-flash-exp',
      systemInstruction: system
    });
    
    const result = await Promise.race([
      model.generateContent(user),
      this.timeoutPromise(timeout)
    ]);
    
    return result.response.text();
  }
  
  private async callClaude(
    system: string,
    user: string
  ): Promise<string> {
    const response = await this.claude.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      system,
      messages: [{ role: 'user', content: user }]
    });
    
    return response.content[0].type === 'text' 
      ? response.content[0].text 
      : '';
  }
  
  private cleanResponse(text: string): string {
    return text
      .replace(/```mermaid\n?/g, '')
      .replace(/```\n?/g, '')
      .trim();
  }
  
  private isValidMermaid(code: string): boolean {
    // 기본 검증: 시작 키워드 확인
    const validStarts = [
      'flowchart', 'graph', 'sequenceDiagram', 
      'gantt', 'erDiagram', 'stateDiagram', 
      'journey', 'pie'
    ];
    
    return validStarts.some(keyword => 
      code.toLowerCase().startsWith(keyword.toLowerCase())
    );
  }
  
  private timeoutPromise(ms: number): Promise<never> {
    return new Promise((_, reject) => 
      setTimeout(() => reject(new Error('Timeout')), ms)
    );
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

#### 📦 Module 3: MermaidValidator

```typescript
// src/lib/mermaid-validator.ts

import mermaid from 'mermaid';

export interface ValidationResult {
  valid: boolean;
  error?: string;
  svg?: string;
}

export class MermaidValidator {
  async validate(code: string): Promise<ValidationResult> {
    try {
      // Mermaid 초기화
      mermaid.initialize({ 
        startOnLoad: false,
        theme: 'default',
        logLevel: 'error'
      });
      
      // 렌더링 시도
      const { svg } = await mermaid.render(
        `diagram-${Date.now()}`,
        code
      );
      
      return {
        valid: true,
        svg
      };
    } catch (error: any) {
      return {
        valid: false,
        error: error.message
      };
    }
  }
  
  async validateAndRetry(
    code: string,
    onError: (error: string) => Promise<string>,
    maxRetries: number = 3
  ): Promise<ValidationResult> {
    for (let i = 0; i < maxRetries; i++) {
      const result = await this.validate(code);
      
      if (result.valid) {
        return result;
      }
      
      console.warn(`⚠️ 검증 실패 (${i + 1}/${maxRetries}):`, result.error);
      
      if (i < maxRetries - 1) {
        // 에러를 기반으로 재생성 요청
        code = await onError(result.error!);
      }
    }
    
    return {
      valid: false,
      error: `${maxRetries}회 재시도 후 실패`
    };
  }
}
```

### 3.3 통합 워크플로우

```typescript
// src/lib/diagram-generator.ts

export class DiagramGenerator {
  private promptEngine: PromptEngine;
  private apiClient: DiagramAPIClient;
  private validator: MermaidValidator;
  
  constructor(geminiKey: string, claudeKey?: string) {
    this.promptEngine = new PromptEngine();
    this.apiClient = new DiagramAPIClient(geminiKey, claudeKey);
    this.validator = new MermaidValidator();
  }
  
  async generate(
    type: string,
    userInput: string
  ): Promise<{ code: string; svg: string }> {
    // Step 1: 프롬프트 생성
    const { system, user } = await this.promptEngine.generatePrompt(type, userInput);
    
    // Step 2: API 호출 (with Retry)
    const code = await this.apiClient.generate(system, user, {
      maxRetries: 3,
      fallbackToClaude: true
    });
    
    // Step 3: 검증 (with Retry)
    const result = await this.validator.validateAndRetry(
      code,
      async (error) => {
        // 에러를 기반으로 재생성
        const retryPrompt = `${user}\n\n이전 시도에서 다음 에러 발생:\n"${error}"\n\n올바른 코드를 생성하세요.`;
        return await this.apiClient.generate(system, retryPrompt, {
          maxRetries: 1
        });
      },
      3
    );
    
    if (!result.valid) {
      throw new Error(`다이어그램 생성 실패: ${result.error}`);
    }
    
    return {
      code,
      svg: result.svg!
    };
  }
}
```

---

## 🧪 Part 4: 테스트 계획

### 4.1 단위 테스트 (Unit Tests)

```typescript
// tests/prompt-engine.test.ts

import { describe, test, expect } from 'bun:test';
import { PromptEngine } from '../src/lib/prompt-engine';

describe('PromptEngine', () => {
  const engine = new PromptEngine();
  
  test('플로우차트 프롬프트 생성', async () => {
    const { system, user } = await engine.generatePrompt(
      'flowchart',
      '로그인 프로세스'
    );
    
    expect(system).toContain('flowchart TD');
    expect(system).toContain('예제');
    expect(user).toContain('로그인 프로세스');
  });
  
  test('파이차트 데이터 전처리', async () => {
    const { user } = await engine.generatePrompt(
      'pie',
      '1월(25%), 2월(30%), 3월(45%)'
    );
    
    expect(user).toContain('"1월" : 25');
    expect(user).not.toContain('%');
  });
});
```

### 4.2 통합 테스트 (Integration Tests)

```typescript
// tests/diagram-generator.test.ts

import { describe, test, expect } from 'bun:test';
import { DiagramGenerator } from '../src/lib/diagram-generator';

describe('DiagramGenerator (플로우차트)', () => {
  const generator = new DiagramGenerator(
    process.env.GEMINI_API_KEY!,
    process.env.ANTHROPIC_API_KEY
  );
  
  test('로그인 플로우차트 생성', async () => {
    const result = await generator.generate(
      'flowchart',
      '로그인 프로세스: 시작 → 이메일 → 비밀번호 → 인증 → 성공/실패'
    );
    
    expect(result.code).toContain('flowchart TD');
    expect(result.code).toContain('시작');
    expect(result.svg).toContain('<svg');
  }, { timeout: 30000 });
  
  test('복잡한 플로우차트 생성', async () => {
    const result = await generator.generate(
      'flowchart',
      '회원가입: 이메일입력 → 중복확인 → 비밀번호입력 → 약관동의 → 인증메일 → 완료'
    );
    
    expect(result.code).toMatch(/\{.*\}/); // 조건 분기 포함
    expect(result.svg).toContain('<svg');
  }, { timeout: 30000 });
});

describe('DiagramGenerator (파이차트)', () => {
  const generator = new DiagramGenerator(
    process.env.GEMINI_API_KEY!,
    process.env.ANTHROPIC_API_KEY
  );
  
  test('파이차트 생성', async () => {
    const result = await generator.generate(
      'pie',
      '월별 매출: 1월(25%), 2월(30%), 3월(45%)'
    );
    
    expect(result.code).toContain('pie');
    expect(result.code).toContain('"1월" : 25');
    expect(result.code).not.toContain('%');
    expect(result.svg).toContain('<svg');
  }, { timeout: 30000 });
  
  test('합계가 100이 아닌 파이차트', async () => {
    const result = await generator.generate(
      'pie',
      'A(30), B(40), C(50)' // 합계 120
    );
    
    // Mermaid는 자동으로 비율 계산하므로 성공해야 함
    expect(result.code).toContain('pie');
    expect(result.svg).toContain('<svg');
  }, { timeout: 30000 });
});
```

### 4.3 A/B 테스트 (실전 검증)

```typescript
// tests/ab-test.ts

import { DiagramGenerator } from '../src/lib/diagram-generator';

async function runABTest() {
  const generator = new DiagramGenerator(
    process.env.GEMINI_API_KEY!,
    process.env.ANTHROPIC_API_KEY
  );
  
  const testCases = [
    { type: 'flowchart', input: '로그인 프로세스' },
    { type: 'flowchart', input: '회원가입 프로세스' },
    { type: 'flowchart', input: '결제 프로세스' },
    { type: 'flowchart', input: '주문 취소 프로세스' },
    { type: 'flowchart', input: 'API 요청 처리' },
    { type: 'pie', input: '1월(25%), 2월(30%), 3월(45%)' },
    { type: 'pie', input: 'A(10), B(20), C(30), D(40)' },
    { type: 'pie', input: '서울(50%), 부산(30%), 대구(20%)' },
  ];
  
  let passed = 0;
  const results: Array<{
    type: string;
    input: string;
    success: boolean;
    duration: number;
    error?: string;
  }> = [];
  
  for (const test of testCases) {
    const startTime = Date.now();
    
    try {
      await generator.generate(test.type, test.input);
      passed++;
      results.push({
        ...test,
        success: true,
        duration: Date.now() - startTime
      });
      console.log(`✅ ${test.type}: ${test.input.substring(0, 30)}...`);
    } catch (error: any) {
      results.push({
        ...test,
        success: false,
        duration: Date.now() - startTime,
        error: error.message
      });
      console.error(`❌ ${test.type}: ${test.input.substring(0, 30)}...`);
    }
  }
  
  const successRate = (passed / testCases.length * 100).toFixed(1);
  const avgDuration = results
    .filter(r => r.success)
    .reduce((sum, r) => sum + r.duration, 0) / (passed || 1);
  
  console.log('\n📊 A/B 테스트 결과:');
  console.log(`   성공률: ${successRate}% (${passed}/${testCases.length})`);
  console.log(`   평균 소요 시간: ${avgDuration.toFixed(0)}ms`);
  console.log(`   목표 달성: ${successRate >= '95' ? '✅' : '❌'}`);
  
  return results;
}

// 실행
runABTest();
```

---

## 📦 Part 5: 배포 패키지

### 5.1 프로젝트 구조

```
snapchart-improved/
├── package.json
├── tsconfig.json
├── .env.example
├── .env
├── bun.lockb
├── src/
│   ├── lib/
│   │   ├── prompt-engine.ts          # 프롬프트 생성 엔진
│   │   ├── api-client.ts             # API 클라이언트 (Retry 포함)
│   │   ├── mermaid-validator.ts      # Mermaid 검증기
│   │   ├── diagram-generator.ts      # 통합 생성기
│   │   └── configs/
│   │       ├── flowchart.config.ts   # 플로우차트 설정
│   │       ├── pie.config.ts         # 파이차트 설정
│   │       └── index.ts
│   └── index.ts                      # 진입점
├── tests/
│   ├── prompt-engine.test.ts
│   ├── diagram-generator.test.ts
│   └── ab-test.ts
├── results/
│   ├── test-report.md
│   └── diagrams/
└── README.md
```

### 5.2 package.json

```json
{
  "name": "snapchart-improved",
  "version": "2.0.0",
  "description": "SnapChart 플로우차트·파이차트 생성 성공률 개선",
  "type": "module",
  "scripts": {
    "test": "bun test",
    "test:unit": "bun test tests/*.test.ts",
    "test:ab": "bun run tests/ab-test.ts",
    "dev": "bun run src/index.ts",
    "build": "bun build src/index.ts --outdir=dist --target=node",
    "clean": "rm -rf dist results/diagrams/*"
  },
  "dependencies": {
    "@google/generative-ai": "^0.21.0",
    "@anthropic-ai/sdk": "^0.32.1",
    "mermaid": "^11.4.0"
  },
  "devDependencies": {
    "@types/node": "^22.10.0",
    "typescript": "^5.7.2"
  },
  "engines": {
    "bun": ">=1.1.0"
  }
}
```

### 5.3 실행 스크립트

```bash
#!/bin/bash
# run-improved-test.sh

echo "🚀 SnapChart 개선 테스트 시작"
echo ""

# 환경 확인
if ! command -v bun &> /dev/null; then
    echo "❌ Bun이 설치되지 않았습니다."
    echo "설치: curl -fsSL https://bun.sh/install | bash"
    exit 1
fi

# API 키 확인
if [ ! -f ".env" ]; then
    echo "❌ .env 파일이 없습니다."
    echo "GEMINI_API_KEY와 ANTHROPIC_API_KEY를 설정하세요."
    exit 1
fi

# 의존성 설치
echo "📦 의존성 설치 중..."
bun install

# 단위 테스트
echo ""
echo "🧪 단위 테스트 실행 중..."
bun test:unit

# A/B 테스트
echo ""
echo "📊 A/B 테스트 실행 중..."
bun test:ab

echo ""
echo "✅ 테스트 완료!"
echo "📄 결과: results/test-report.md"
```

---

## 🎯 Part 6: 성공 기준 & 검증

### 6.1 목표 지표

| 지표 | 현재 | 목표 | 측정 방법 |
|------|------|------|-----------|
| **플로우차트 성공률** | 0% | 95%+ | 10회 테스트 |
| **파이차트 성공률** | 0% | 95%+ | 10회 테스트 |
| **전체 성공률** | 75% | 95%+ | 8개 타입 × 5회 |
| **평균 응답 시간** | 6.2초 | 4.5초 | Bun 적용 |
| **Gemini 성공률** | 70% | 90%+ | Primary API |
| **Claude Fallback 비율** | - | <10% | 보조 API |

### 6.2 검증 프로세스

#### Phase 1: 개발 환경 검증 (1일)
```
□ 단위 테스트 100% 통과
□ 플로우차트 프롬프트 10회 테스트 → 95%+ 성공
□ 파이차트 프롬프트 10회 테스트 → 95%+ 성공
□ 코드 리뷰 완료
```

#### Phase 2: 통합 테스트 (2일)
```
□ 8개 타입 각 5회 테스트 (총 40회)
□ 성공률 95%+ 달성 확인
□ 평균 응답 시간 5초 이내 확인
□ 메모리 누수 없음 확인
```

#### Phase 3: 실전 검증 (3일)
```
□ 베타 사용자 10명 테스트
□ 100개 실제 입력 테스트
□ Edge Case 테스트 (비정상 입력)
□ 부하 테스트 (100 req/min)
```

### 6.3 Go/No-Go 판단

```
✅ GO (즉시 MVP 개발 진행)
- 플로우차트 성공률 ≥ 95%
- 파이차트 성공률 ≥ 95%
- 전체 성공률 ≥ 95%
- 평균 응답 시간 ≤ 5초

⚠️ CAUTION (추가 개선)
- 플로우차트 성공률 90~95%
- 파이차트 성공률 90~95%
- 프롬프트 미세 조정 필요

❌ NO-GO (재설계)
- 플로우차트 성공률 < 90%
- 대안 API 검토 (GPT-4o)
```

---

## 📅 Part 7: 구현 일정

### 7.1 개발 타임라인 (5일)

#### Day 1: 프롬프트 엔진 개발
```
AM (4h):
- PromptEngine 클래스 구현
- 플로우차트 Config 작성
- Few-Shot 예제 3개 작성

PM (4h):
- 파이차트 Config 작성
- 데이터 전처리 로직 구현
- 단위 테스트 작성
```

#### Day 2: API 클라이언트 개발
```
AM (4h):
- APIClient 클래스 구현
- Retry 메커니즘 구현
- Timeout 처리

PM (4h):
- Claude Fallback 구현
- Exponential Backoff 적용
- 에러 핸들링 강화
```

#### Day 3: 검증 시스템 개발
```
AM (4h):
- MermaidValidator 구현
- 문법 검증 로직
- 렌더링 테스트

PM (4h):
- DiagramGenerator 통합
- End-to-End 테스트
- 성능 최적화
```

#### Day 4: 테스트 & 검증
```
AM (4h):
- 단위 테스트 실행
- 통합 테스트 실행
- A/B 테스트 (10회씩)

PM (4h):
- 버그 수정
- Edge Case 처리
- 문서화
```

#### Day 5: 최종 검증 & 배포 준비
```
AM (4h):
- 베타 테스터 초대
- 실전 데이터 테스트
- 성공률 측정

PM (4h):
- 리포트 작성
- Go/No-Go 판단
- MVP 개발 계획 수립
```

### 7.2 Task 체크리스트

```markdown
## 개발 Task (19개)

### Core Engine (7개)
- [ ] PromptEngine 클래스 구현
- [ ] 플로우차트 Config (Few-Shot 포함)
- [ ] 파이차트 Config (데이터 전처리 포함)
- [ ] APIClient 클래스 구현
- [ ] Retry & Timeout 메커니즘
- [ ] Claude Fallback 로직
- [ ] MermaidValidator 구현

### Testing (6개)
- [ ] PromptEngine 단위 테스트
- [ ] APIClient 단위 테스트
- [ ] MermaidValidator 단위 테스트
- [ ] DiagramGenerator 통합 테스트
- [ ] A/B 테스트 스크립트
- [ ] 성능 벤치마크

### Documentation (3개)
- [ ] API 문서 작성
- [ ] 사용 가이드 작성
- [ ] 테스트 리포트 생성

### Deployment (3개)
- [ ] package.json 설정
- [ ] 실행 스크립트 작성
- [ ] CI/CD 파이프라인 설정
```

---

## 💡 Part 8: 예상 결과

### 8.1 성공 시나리오

```
📊 최종 테스트 결과 (예상)
━━━━━━━━━━━━━━━━━━━━━━━━
플로우차트:  ✅ 96% (48/50)
파이차트:    ✅ 98% (49/50)
━━━━━━━━━━━━━━━━━━━━━━━━
전체 성공률: ✅ 97.5% (390/400)

⚡ 성능 지표
━━━━━━━━━━━━━━━━━━━━━━━━
평균 응답 시간: 4.2초 (Bun 적용)
Gemini 성공률: 92%
Claude Fallback: 5% (20/400)
캐시 적중률: 0% (초기)

💰 비용 분석
━━━━━━━━━━━━━━━━━━━━━━━━
Gemini 비용: $0.0020/요청 (92%)
Claude 비용: $0.0165/요청 (5%)
━━━━━━━━━━━━━━━━━━━━━━━━
평균 비용: $0.0026/요청
(기존 목표 $0.0020 대비 +30%, 여전히 경쟁력 있음)

🎯 최종 판정
━━━━━━━━━━━━━━━━━━━━━━━━
✅ GO - 즉시 MVP 개발 진행!
```

### 8.2 실패 시 대안

```
만약 목표 미달 시 (< 90%):

Plan B: 프롬프트 추가 개선
- Few-Shot 예제 3개 → 5개로 증가
- Chain-of-Thought 프롬프트 적용
- 더 명시적인 출력 제약 조건

Plan C: Hybrid 전략
- 플로우차트: Claude 전용
- 나머지 7개: Gemini
- 비용은 증가하지만 품질 보장

Plan D: API 변경
- Gemini → GPT-4o mini 테스트
- 비용 비교 ($0.0015 vs $0.0020)
- 성공률 재측정
```

---

## 📝 Part 9: 최종 요약

### 핵심 전략

1. **프롬프트 엔지니어링** (가장 중요)
   - Few-Shot 학습 적용
   - 명시적 출력 포맷 지정
   - 타입별 맞춤 템플릿

2. **재시도 메커니즘**
   - 최대 3회 자동 재시도
   - Exponential Backoff
   - Claude Fallback (5% 예상)

3. **검증 시스템**
   - Mermaid 문법 사전 검증
   - 렌더링 테스트 통과 시 확정
   - 실패 시 에러 피드백 기반 재생성

4. **성능 최적화**
   - Node.js → Bun (4배 빠름)
   - 평균 6.2초 → 4.2초 예상

### 예상 성과

| 지표 | 개선 전 | 개선 후 | 개선율 |
|------|---------|---------|--------|
| 플로우차트 성공률 | 0% | 96% | +96%p |
| 파이차트 성공률 | 0% | 98% | +98%p |
| 전체 성공률 | 75% | 97.5% | +22.5%p |
| 평균 응답 시간 | 6.2초 | 4.2초 | -32% |
| 비용 | $0.0020 | $0.0026 | +30% |

### 다음 단계

```
✅ Day 1-5: 개선 구현 및 테스트
✅ Day 6: Go/No-Go 판단
✅ Day 7: MVP 개발 착수

예상 MVP 출시: 7주 후
```

---

**명세서 작성 완료**  
**작성자**: 아테나 (AI 엔지니어) + 덱스 (풀스택)  
**승인 대기**: CEO  
**다음 업데이트**: 5일 후 (테스트 결과 리포트)